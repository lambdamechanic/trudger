#!/usr/bin/env bash
set -euo pipefail
set -o errtrace

# trudger: loop over br tasks and run Codex solve+review prompts.

PROMPT_TRUDGE="${HOME}/.codex/prompts/trudge.md"
PROMPT_REVIEW="${HOME}/.codex/prompts/trudge_review.md"
DEFAULT_CONFIG_PATH="${HOME}/.config/trudger.yml"
CONFIG_PATH="${DEFAULT_CONFIG_PATH}"
CONFIG_PATH_SOURCE="default"

# --- Usage ---
usage() {
  cat <<'EOF'
Usage: ./trudger [options] [task_id ...]

Loop over ready br tasks and run Codex solve+review prompts.
If task IDs are provided, they run first (in order) before br ready tasks.
Configuration is loaded from ~/.config/trudger.yml by default.

Options:
  -c, --config PATH   Load configuration from PATH instead of ~/.config/trudger.yml.
  -h, --help          Show this help text.
EOF
}

# --- Environment checks ---
require_prompt() {
  local path="$1"
  if [[ ! -f "$path" ]]; then
    printf 'Missing prompt file: %s\n' "$path" >&2
    quit "missing_prompt:${path}" 1
  fi
}

require_jq() {
  if ! command -v jq >/dev/null 2>&1; then
    printf 'Missing dependency: jq\n' >&2
    quit "missing_dependency:jq" 1
  fi
}

# --- Logging ---
log_transition() {
  local message="$1"
  local ts
  ts="$(date -u '+%Y-%m-%dT%H:%M:%SZ')"
  local path="${trudger_log_path:-}"
  if [[ -z "$path" ]]; then
    return 0
  fi
  printf '%s %s\n' "$ts" "$message" >> "$path" 2>/dev/null || true
}

sanitize_log_value() {
  local value="$1"
  value="${value//$'\n'/\\n}"
  value="${value//$'\r'/\\r}"
  value="${value//$'\t'/\\t}"
  printf '%s' "$value"
}

quit() {
  local reason="${1:-}"
  local code="${2:-0}"
  local sanitized
  if [[ -z "$reason" ]]; then
    sanitized="unknown"
  else
    sanitized="$(sanitize_log_value "$reason")"
  fi
  log_transition "quit reason=${sanitized}"
  exit "$code"
}

# --- Tmux helpers ---
is_tmux_session() {
  [[ -n "${TMUX:-}" ]] && command -v tmux >/dev/null 2>&1
}

default_tmux_base_name() {
  local host folder command
  host="$(hostname -s 2>/dev/null || hostname 2>/dev/null || printf 'host')"
  folder="$(basename "$PWD")"
  command="$(basename "$0")"
  printf '(%s) %s: %s' "$host" "$folder" "$command"
}

init_tmux_base_name() {
  if ! is_tmux_session; then
    return 0
  fi

  tmux_session_name="${TRUDGER_TMUX_SESSION_NAME:-}"
  if [[ -z "${tmux_session_name}" ]]; then
    tmux_session_name="$(tmux display-message -p '#S' 2>/dev/null || true)"
  fi
  export TRUDGER_TMUX_SESSION_NAME="${tmux_session_name}"

  tmux_original_pane_title="${TRUDGER_TMUX_ORIGINAL_PANE_TITLE:-}"
  if [[ -z "${tmux_original_pane_title}" ]]; then
    tmux_original_pane_title="$(tmux display-message -p '#{pane_title}' 2>/dev/null || true)"
  fi
  export TRUDGER_TMUX_ORIGINAL_PANE_TITLE="${tmux_original_pane_title}"

  if [[ -n "${tmux_original_pane_title}" ]]; then
    tmux_base_name="$(printf '%s\n' "$tmux_original_pane_title" | sed -E 's/ (COMPLETED|NEEDS_HUMAN) \\[[^]]*\\]//g; s/ (SOLVING|REVIEWING) .*$//; s/ HALTED ON ERROR .*$//')"
  fi
  if [[ -z "${tmux_base_name:-}" ]]; then
    tmux_base_name="$(default_tmux_base_name)"
  fi
  tmux select-pane -T "${tmux_base_name}" >/dev/null 2>&1 || true
}

format_task_list() {
  local label="$1"
  shift
  if (($# == 0)); then
    printf '%s' ""
    return
  fi
  local IFS=", "
  printf '%s [%s]' "$label" "$*"
}

build_tmux_name() {
  local phase="$1"
  local task_id="$2"
  local base="${tmux_base_name:-}"
  if [[ "$base" =~ ^(.+):\ ([^[:space:]]+)$ ]]; then
    local prefix="${BASH_REMATCH[1]}"
    local command="${BASH_REMATCH[2]}"
    case "$command" in
      fg|codex)
        base="$prefix"
        ;;
    esac
  fi
  if [[ -z "$base" ]]; then
    base="$(default_tmux_base_name)"
  fi

  local activity=""
  case "$phase" in
    SOLVING)
      activity="SOLVING $task_id"
      ;;
    REVIEWING)
      activity="REVIEWING $task_id"
      ;;
    ERROR)
      activity="HALTED ON ERROR $task_id"
      ;;
    *)
      ;;
  esac

  local parts=()
  parts+=("$base")
  local completed_segment needs_human_segment
  completed_segment="$(format_task_list "COMPLETED" "${completed_tasks[@]:-}")"
  needs_human_segment="$(format_task_list "NEEDS_HUMAN" "${needs_human_tasks[@]:-}")"
  if [[ -n "$completed_segment" ]]; then
    parts+=("$completed_segment")
  fi
  if [[ -n "$needs_human_segment" ]]; then
    parts+=("$needs_human_segment")
  fi
  if [[ -n "$activity" ]]; then
    parts+=("$activity")
  fi

  local IFS=" "
  printf '%s' "${parts[*]}"
}

update_tmux_name() {
  local phase="$1"
  local task_id="$2"
  if ! is_tmux_session; then
    return 0
  fi

  local name
  name="$(build_tmux_name "$phase" "$task_id")"
  tmux select-pane -T "$name" >/dev/null 2>&1 || true
}

# --- Config parsing ---
require_yq() {
  if ! command -v yq >/dev/null 2>&1; then
    cat <<'EOF' >&2
Missing dependency: yq

Install yq and ensure it is on your PATH, then re-run trudger.
Common options:
  - macOS: brew install yq
  - Linux: https://github.com/mikefarah/yq#install
EOF
    quit "missing_dependency:yq" 1
  fi
}

detect_yq_mode() {
  if yq eval -r '.' "$CONFIG_PATH" >/dev/null 2>&1; then
    printf '%s' "mikefarah"
    return 0
  fi
  if yq -r '.' "$CONFIG_PATH" >/dev/null 2>&1; then
    printf '%s' "kislyuk"
    return 0
  fi
  return 1
}

read_config_value() {
  local query="$1"
  local mode="$2"
  local value
  if [[ "$mode" == "mikefarah" ]]; then
    value="$(yq eval -r "$query" "$CONFIG_PATH")"
  else
    value="$(yq -r "$query" "$CONFIG_PATH")"
  fi
  if [[ "$value" == "null" ]]; then
    value=""
  fi
  printf '%s' "$value"
}

load_config() {
  if [[ ! -f "$CONFIG_PATH" ]]; then
    if [[ "$CONFIG_PATH_SOURCE" == "flag" ]]; then
      printf 'Missing config file: %s\n' "$CONFIG_PATH" >&2
      quit "missing_config:${CONFIG_PATH}" 1
    fi
    cat <<'EOF' >&2
Missing config file: ~/.config/trudger.yml

Sample configurations:

1) Trudgeable with hooks
   - Selects the next ready br task labeled "trudgeable".
   - On completion, removes the "trudgeable" label.
   - On requires-human, removes "trudgeable" and adds "human-required".
   mkdir -p ~/.config && curl -fsSL https://raw.githubusercontent.com/lambdamechanic/trudger/main/sample_configuration/trudgeable-with-hooks.yml -o ~/.config/trudger.yml

2) Robot triage
   - Selects tasks via `bv --robot-next`.
   - No label changes (hooks are no-ops).
   mkdir -p ~/.config && curl -fsSL https://raw.githubusercontent.com/lambdamechanic/trudger/main/sample_configuration/robot-triage.yml -o ~/.config/trudger.yml
EOF
    quit "missing_config:${CONFIG_PATH}" 1
  fi

  require_yq

  local yq_mode
  if ! yq_mode="$(detect_yq_mode)"; then
    printf 'Invalid config file (failed to parse YAML): %s\n' "$CONFIG_PATH" >&2
    quit "invalid_config_parse:${CONFIG_PATH}" 1
  fi

  codex_command="$(read_config_value '.codex_command' "$yq_mode")"
  review_loop_limit="$(read_config_value '.review_loop_limit' "$yq_mode")"
  trudger_log_path="$(read_config_value '.log_path' "$yq_mode")"
  next_task_command="$(read_config_value '.commands.next_task' "$yq_mode")"
  task_show_command="$(read_config_value '.commands.task_show' "$yq_mode")"
  task_status_command="$(read_config_value '.commands.task_status' "$yq_mode")"
  task_update_in_progress_command="$(read_config_value '.commands.task_update_in_progress' "$yq_mode")"
  hook_on_completed="$(read_config_value '.hooks.on_completed' "$yq_mode")"
  hook_on_requires_human="$(read_config_value '.hooks.on_requires_human' "$yq_mode")"

  local key
  while IFS= read -r key; do
    case "$key" in
      codex_command|commands|hooks|review_loop_limit|log_path)
        ;;
      *)
        printf 'Warning: Unknown config key: %s\n' "$key" >&2
        ;;
    esac
  done < <(if [[ "$yq_mode" == "mikefarah" ]]; then yq eval -r 'keys | .[]' "$CONFIG_PATH"; else yq -r 'keys | .[]' "$CONFIG_PATH"; fi)
}

validate_config() {
  if [[ -z "$codex_command" ]]; then
    printf 'codex_command must not be empty.\n' >&2
    quit "missing_codex_command" 1
  fi
  if [[ -z "$next_task_command" ]]; then
    if ((${#manual_tasks[@]} > 0)); then
      printf 'Warning: commands.next_task is empty; manual task IDs provided, continuing without next_task.\n' >&2
    else
      printf 'commands.next_task must not be empty.\n' >&2
      printf 'Migration: add commands.next_task to your config (required when no manual task IDs). See README.md or sample_configuration/*.yml.\n' >&2
      quit "missing_next_task_command" 1
    fi
  fi
  if [[ -z "$task_show_command" ]]; then
    printf 'commands.task_show must not be empty.\n' >&2
    quit "missing_task_show_command" 1
  fi
  if [[ -z "$task_status_command" ]]; then
    printf 'commands.task_status must not be empty.\n' >&2
    quit "missing_task_status_command" 1
  fi
  if [[ -z "$task_update_in_progress_command" ]]; then
    printf 'commands.task_update_in_progress must not be empty.\n' >&2
    quit "missing_task_update_in_progress_command" 1
  fi
  if [[ -z "$hook_on_completed" ]]; then
    printf 'hooks.on_completed must not be empty.\n' >&2
    quit "missing_hook_on_completed" 1
  fi
  if [[ -z "$hook_on_requires_human" ]]; then
    printf 'hooks.on_requires_human must not be empty.\n' >&2
    quit "missing_hook_on_requires_human" 1
  fi
  if [[ -z "$trudger_log_path" ]]; then
    printf 'log_path must not be empty.\n' >&2
    quit "missing_log_path" 1
  fi
  if ! [[ "$review_loop_limit" =~ ^[0-9]+$ ]] || ((review_loop_limit < 1)); then
    printf 'review_loop_limit must be a positive integer (got %s).\n' "$review_loop_limit" >&2
    quit "invalid_review_loop_limit" 1
  fi
}

# --- Command helpers ---
run_shell_command() {
  local command="$1"
  local log_label="$2"
  shift 2
  local args=("$@")

  if [[ -z "$command" ]]; then
    return 0
  fi

  log_transition "cmd label=${log_label} mode=bash_lc args=$(sanitize_log_value "$(printf '%q ' "${args[@]}")")"
  local errexit_enabled=0
  if [[ $- == *e* ]]; then
    errexit_enabled=1
  fi
  set +e
  if ((${#args[@]} > 0)); then
    bash -lc "$command" -- "${args[@]}"
  else
    bash -lc "$command"
  fi
  local exit_code=$?
  if ((errexit_enabled)); then
    set -e
  fi
  log_transition "cmd label=${log_label} exit=${exit_code}"
  return "$exit_code"
}

run_config_command() {
  local command="$1"
  local task_id="$2"
  local shell_label="$3"
  local log_label="${4:-$shell_label}"
  shift 4
  local extra_args=("$@")

  if [[ -z "$command" ]]; then
    return 0
  fi

  local task_token="none"
  if [[ -n "$task_id" ]]; then
    task_token="$task_id"
  fi
  log_transition "cmd start label=${log_label} task=${task_token} command=$(sanitize_log_value "$command")"

  local args=()
  if [[ -n "$task_id" ]]; then
    args+=("$task_id")
  fi
  if ((${#extra_args[@]} > 0)); then
    args+=("${extra_args[@]}")
  fi
  run_shell_command "$command" "$log_label" "${args[@]}"
}

run_codex_command() {
  local command="$1"
  shift
  local args=("$@")

  log_transition "cmd start label=codex task=none command=$(sanitize_log_value "$command")"
  run_shell_command "$command" "codex" "${args[@]}"
}

run_hook() {
  local hook_command="$1"
  local task_id="$2"
  local hook_name="${3:-hook}"
  if [[ -z "$hook_command" ]]; then
    return 0
  fi
  run_config_command "$hook_command" "$task_id" "hook" "$hook_name"
}

run_task_command() {
  local command="$1"
  local task_id="$2"
  shift 2
  local extra_args=("$@")

  run_config_command "$command" "$task_id" "task" "task" "${extra_args[@]}"
}

run_task_show() {
  local task_id="$1"
  shift
  local raw exit_code
  local errexit_enabled=0
  if [[ $- == *e* ]]; then
    errexit_enabled=1
  fi
  set +e
  raw="$(run_task_command "$task_show_command" "$task_id" "$@")"
  exit_code=$?
  if ((errexit_enabled)); then
    set -e
  fi
  if [[ "$exit_code" -ne 0 ]]; then
    printf 'task_show command failed with exit code %s.\n' "$exit_code" >&2
    quit "task_show_failed:${exit_code}" "$exit_code"
  fi
  printf '%s' "$raw"
}

run_task_status() {
  local task_id="$1"
  run_task_command "$task_status_command" "$task_id"
}

# --- Task selection and state ---
get_next_task_id() {
  local raw exit_code
  set +e
  raw="$(run_config_command "$next_task_command" "" "next-task" "next-task" 2>/dev/null)"
  exit_code=$?
  set -e
  if [[ "$exit_code" -eq 1 ]]; then
    log_transition "idle next_task_exit=1"
    quit "no_next_task" 0
  fi
  if [[ "$exit_code" -ne 0 ]]; then
    printf 'next_task command failed with exit code %s.\n' "$exit_code" >&2
    quit "next_task_failed:${exit_code}" "$exit_code"
  fi
  printf '%s' "$raw" | awk 'NF { print $1; exit }'
}

task_status() {
  local task_id="$1"
  local raw exit_code status
  local errexit_enabled=0
  if [[ $- == *e* ]]; then
    errexit_enabled=1
  fi
  set +e
  raw="$(run_task_status "$task_id")"
  exit_code=$?
  if ((errexit_enabled)); then
    set -e
  fi
  if [[ "$exit_code" -ne 0 ]]; then
    printf 'task_status command failed with exit code %s.\n' "$exit_code" >&2
    quit "task_status_failed:${exit_code}" "$exit_code"
  fi
  status="$(printf '%s' "$raw" | awk 'NF { print $1; exit }')"
  printf '%s' "$status"
}

is_ready_status() {
  local status="$1"
  [[ "$status" == "ready" || "$status" == "open" ]]
}

ensure_task_ready() {
  local task_id="$1"
  local status
  status="$(task_status "$task_id")"
  if is_ready_status "$status"; then
    return 0
  fi
  printf 'Task %s is not ready (status: %s).\n' "$task_id" "${status:-unknown}" >&2
  quit "task_not_ready:${task_id}" 1
}

# --- Prompt rendering ---
escape_prompt_replacement() {
  local value="$1"
  value="${value//\\/\\\\}"
  value="${value//&/\\&}"
  printf '%s' "$value"
}

render_prompt() {
  local prompt_path="$1"
  local task_id="$2"
  local task_show_output="$3"
  local content

  content="$(awk '
    NR == 1 && $0 == "---" { in_frontmatter = 1; next }
    in_frontmatter && $0 == "---" { in_frontmatter = 0; next }
    !in_frontmatter { print }
  ' "$prompt_path")"
  local safe_task_id
  local safe_task_show
  safe_task_id="$(escape_prompt_replacement "$task_id")"
  safe_task_show="$(escape_prompt_replacement "$task_show_output")"
  content="${content//\$ARGUMENTS/$safe_task_id}"
  content="${content//\$TASK_SHOW/$safe_task_show}"
  printf '%s' "${content}"
}

# --- Main ---
manual_tasks=()
while (($#)); do
  case "$1" in
    -h|--help)
      usage
      quit "help" 0
      ;;
    -c|--config)
      option="$1"
      shift
      if (($# == 0)) || [[ -z "$1" ]]; then
        printf 'Missing value for %s\n' "$option" >&2
        usage
        quit "missing_option_value:${option}" 1
      fi
      CONFIG_PATH="$1"
      CONFIG_PATH_SOURCE="flag"
      ;;
    --config=*)
      CONFIG_PATH="${1#*=}"
      CONFIG_PATH_SOURCE="flag"
      if [[ -z "$CONFIG_PATH" ]]; then
        printf 'Missing value for --config\n' >&2
        usage
        quit "missing_option_value:--config" 1
      fi
      ;;
    --)
      shift
      manual_tasks+=("$@")
      break
      ;;
    -*)
      printf 'Unknown option: %s\n' "$1" >&2
      usage
      quit "unknown_option:${1}" 1
      ;;
    *)
      manual_tasks+=("$1")
      ;;
  esac
  shift
done

codex_command=""
next_task_command=""
task_show_command=""
task_status_command=""
task_update_in_progress_command=""
review_loop_limit=""
trudger_log_path=""
hook_on_completed=""
hook_on_requires_human=""

load_config
validate_config

require_jq
require_prompt "$PROMPT_TRUDGE"
require_prompt "$PROMPT_REVIEW"
init_tmux_base_name

completed_tasks=()
needs_human_tasks=()
if [[ -n "${TRUDGER_COMPLETED:-}" ]]; then
  IFS=',' read -r -a completed_tasks <<< "${TRUDGER_COMPLETED}"
fi
if [[ -n "${TRUDGER_NEEDS_HUMAN:-}" ]]; then
  IFS=',' read -r -a needs_human_tasks <<< "${TRUDGER_NEEDS_HUMAN}"
fi
current_task_id=""
current_phase=""

review_args=("resume" "--last")

handle_error() {
  if [[ -n "${current_task_id}" ]]; then
    update_tmux_name "ERROR" "$current_task_id"
    log_transition "error task=${current_task_id}"
  fi
  log_transition "quit reason=error"
}

trap handle_error ERR

handle_interrupt() {
  if [[ -n "${current_task_id}" ]]; then
    update_tmux_name "ERROR" "$current_task_id"
    log_transition "interrupt task=${current_task_id}"
  fi
  quit "interrupt" 130
}

trap handle_interrupt INT

restore_tmux_pane_title() {
  if ! is_tmux_session; then
    return 0
  fi
  if [[ -n "${tmux_original_pane_title:-}" ]]; then
    tmux select-pane -T "${tmux_original_pane_title}" >/dev/null 2>&1 || true
  fi
}

handle_exit() {
  local exit_code="$?"
  restore_tmux_pane_title
  log_transition "exit code=${exit_code}"
}

trap handle_exit EXIT

if ((${#manual_tasks[@]} > 0)); then
  for task_id in "${manual_tasks[@]}"; do
    ensure_task_ready "$task_id"
  done
fi

if ((${#manual_tasks[@]} > 0)); then
  task_id="${manual_tasks[0]}"
  manual_tasks=("${manual_tasks[@]:1}")
else
  skip_not_ready_limit="${TRUDGER_SKIP_NOT_READY_LIMIT:-5}"
  if ! [[ "$skip_not_ready_limit" =~ ^[0-9]+$ ]] || ((skip_not_ready_limit < 1)); then
    skip_not_ready_limit=5
  fi
  skip_count=0
  while true; do
    task_id="$(get_next_task_id)"
    if [[ -z "$task_id" ]]; then
      log_transition "idle no_task"
      quit "no_task" 0
    fi
    status="$(task_status "$task_id")"
    if [[ -z "$status" ]]; then
      printf 'Task %s missing status.\n' "$task_id" >&2
      quit "task_missing_status:${task_id}" 1
    fi
    if is_ready_status "$status"; then
      break
    fi
    log_transition "skip_not_ready task=${task_id} status=${status}"
    skip_count=$((skip_count + 1))
    if ((skip_count >= skip_not_ready_limit)); then
      log_transition "idle no_ready_task attempts=${skip_count}"
      printf 'Task %s is not ready (status: %s).\n' "$task_id" "$status" >&2
      quit "no_ready_task" 0
    fi
  done
fi
if [[ -z "$task_id" ]]; then
  log_transition "idle no_task"
  quit "no_task" 0
fi

review_loops=0
while true; do
  current_task_id="$task_id"
  current_phase="SOLVING"
  update_tmux_name "$current_phase" "$task_id"
  log_transition "state=SOLVING task=${task_id} loop=${review_loops}"

  run_task_command "$task_update_in_progress_command" "$task_id" --status in_progress
  task_show_output="$(run_task_show "$task_id" --json)"
  if ! run_codex_command "$codex_command" "$(render_prompt "$PROMPT_TRUDGE" "$task_id" "$task_show_output")"; then
    update_tmux_name "ERROR" "$task_id"
    log_transition "solve_failed task=${task_id}"
    printf 'Codex solve failed for task %s.\n' "$task_id" >&2
    quit "solve_failed:${task_id}" 1
  fi
  current_phase="REVIEWING"
  update_tmux_name "$current_phase" "$task_id"
  log_transition "state=REVIEWING task=${task_id} loop=${review_loops}"
  task_show_output="$(run_task_show "$task_id" --json)"
  if ! run_codex_command "$codex_command" "${review_args[@]}" "$(render_prompt "$PROMPT_REVIEW" "$task_id" "$task_show_output")"; then
    update_tmux_name "ERROR" "$task_id"
    log_transition "review_failed task=${task_id}"
    printf 'Codex review failed for task %s.\n' "$task_id" >&2
    quit "review_failed:${task_id}" 1
  fi

  status="$(task_status "$task_id")"
  log_transition "review_state task=${task_id} status=${status:-unknown}"

  if [[ -z "$status" ]]; then
    update_tmux_name "ERROR" "$task_id"
    log_transition "review_state_missing task=${task_id}"
    printf 'Task %s missing status after review.\n' "$task_id" >&2
    quit "task_missing_status_after_review:${task_id}" 1
  fi

  if [[ "$status" == "closed" ]]; then
    completed_tasks+=("$task_id")
    log_transition "completed task=${task_id}"
    run_hook "$hook_on_completed" "$task_id" "on_completed"
    break
  fi

  needs_human_tasks+=("$task_id")
  log_transition "needs_human task=${task_id}"
  run_hook "$hook_on_requires_human" "$task_id" "on_requires_human"
  break
done

TRUDGER_COMPLETED="$(IFS=','; printf '%s' "${completed_tasks[*]:-}")"
log_transition "env TRUDGER_COMPLETED=${TRUDGER_COMPLETED}"
export TRUDGER_COMPLETED
TRUDGER_NEEDS_HUMAN="$(IFS=','; printf '%s' "${needs_human_tasks[*]:-}")"
export TRUDGER_NEEDS_HUMAN

reexec_path="$0"
if command -v "$0" >/dev/null 2>&1; then
  reexec_path="$(command -v "$0")"
fi
if ((${#manual_tasks[@]} == 0)) && [[ -z "$next_task_command" ]]; then
  log_transition "idle missing_next_task_command"
  quit "missing_next_task_command" 0
fi
log_transition "reexec path=${reexec_path} next_tasks=${#manual_tasks[@]}"
parse_error=""
if ! parse_error="$(bash -n "$reexec_path" 2>&1)"; then
  log_transition "reexec parse_failed path=$(sanitize_log_value "$reexec_path") error=$(sanitize_log_value "$parse_error")"
  snapshot_path="/tmp/trudger.reexec-bad.$(date -u '+%Y%m%dT%H%M%SZ').$$"
  cp "$reexec_path" "$snapshot_path" 2>/dev/null || true
  log_transition "reexec parse_failed_copy path=$(sanitize_log_value "$snapshot_path")"
  quit "reexec_parse_failed" 2
fi
exec "$0" "${manual_tasks[@]}"

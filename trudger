#!/usr/bin/env bash
set -euo pipefail
set -o errtrace

# trudger: loop over br tasks and run Codex solve+review prompts.

PROMPT_TRUDGE="${HOME}/.codex/prompts/trudge.md"
PROMPT_REVIEW="${HOME}/.codex/prompts/trudge_review.md"
CONFIG_PATH="${HOME}/.config/trudger.yml"

# --- Usage ---
usage() {
  cat <<'EOF'
Usage: ./trudger [task_id ...]

Loop over ready br tasks and run Codex solve+review prompts.
If task IDs are provided, they run first (in order) before br ready tasks.
Configuration is loaded from ~/.config/trudger.yml.
EOF
}

# --- Environment checks ---
require_prompt() {
  local path="$1"
  if [[ ! -f "$path" ]]; then
    printf 'Missing prompt file: %s\n' "$path" >&2
    exit 1
  fi
}

require_jq() {
  if ! command -v jq >/dev/null 2>&1; then
    printf 'Missing dependency: jq\n' >&2
    exit 1
  fi
}

# --- Logging ---
log_transition() {
  local message="$1"
  local ts
  ts="$(date -u '+%Y-%m-%dT%H:%M:%SZ')"
  printf '%s %s\n' "$ts" "$message" >> "$trudger_log_path" 2>/dev/null || true
}

# --- Tmux helpers ---
is_tmux_session() {
  [[ -n "${TMUX:-}" ]] && command -v tmux >/dev/null 2>&1
}

default_tmux_base_name() {
  local host folder command
  host="$(hostname -s 2>/dev/null || hostname 2>/dev/null || printf 'host')"
  folder="$(basename "$PWD")"
  command="$(basename "$0")"
  printf '(%s) %s: %s' "$host" "$folder" "$command"
}

init_tmux_base_name() {
  if ! is_tmux_session; then
    return 0
  fi

  tmux_session_name="${TRUDGER_TMUX_SESSION_NAME:-}"
  if [[ -z "${tmux_session_name}" ]]; then
    tmux_session_name="$(tmux display-message -p '#S' 2>/dev/null || true)"
  fi
  export TRUDGER_TMUX_SESSION_NAME="${tmux_session_name}"

  tmux_original_pane_title="${TRUDGER_TMUX_ORIGINAL_PANE_TITLE:-}"
  if [[ -z "${tmux_original_pane_title}" ]]; then
    tmux_original_pane_title="$(tmux display-message -p '#{pane_title}' 2>/dev/null || true)"
  fi
  export TRUDGER_TMUX_ORIGINAL_PANE_TITLE="${tmux_original_pane_title}"

  if [[ -n "${tmux_original_pane_title}" ]]; then
    tmux_base_name="$(printf '%s\n' "$tmux_original_pane_title" | sed -E 's/ (COMPLETED|NEEDS_HUMAN) \\[[^]]*\\]//g; s/ (SOLVING|REVIEWING) .*$//; s/ HALTED ON ERROR .*$//')"
  fi
  if [[ -z "${tmux_base_name:-}" ]]; then
    tmux_base_name="$(default_tmux_base_name)"
  fi
  tmux select-pane -T "${tmux_base_name}" >/dev/null 2>&1 || true
}

format_task_list() {
  local label="$1"
  shift
  if (($# == 0)); then
    printf '%s' ""
    return
  fi
  local IFS=", "
  printf '%s [%s]' "$label" "$*"
}

build_tmux_name() {
  local phase="$1"
  local task_id="$2"
  local base="${tmux_base_name:-}"
  if [[ "$base" =~ ^(.+):\ ([^[:space:]]+)$ ]]; then
    local prefix="${BASH_REMATCH[1]}"
    local command="${BASH_REMATCH[2]}"
    case "$command" in
      fg|codex)
        base="$prefix"
        ;;
    esac
  fi
  if [[ -z "$base" ]]; then
    base="$(default_tmux_base_name)"
  fi

  local activity=""
  case "$phase" in
    SOLVING)
      activity="SOLVING $task_id"
      ;;
    REVIEWING)
      activity="REVIEWING $task_id"
      ;;
    ERROR)
      activity="HALTED ON ERROR $task_id"
      ;;
    *)
      ;;
  esac

  local parts=()
  parts+=("$base")
  local completed_segment needs_human_segment
  completed_segment="$(format_task_list "COMPLETED" "${completed_tasks[@]:-}")"
  needs_human_segment="$(format_task_list "NEEDS_HUMAN" "${needs_human_tasks[@]:-}")"
  if [[ -n "$completed_segment" ]]; then
    parts+=("$completed_segment")
  fi
  if [[ -n "$needs_human_segment" ]]; then
    parts+=("$needs_human_segment")
  fi
  if [[ -n "$activity" ]]; then
    parts+=("$activity")
  fi

  local IFS=" "
  printf '%s' "${parts[*]}"
}

update_tmux_name() {
  local phase="$1"
  local task_id="$2"
  if ! is_tmux_session; then
    return 0
  fi

  local name
  name="$(build_tmux_name "$phase" "$task_id")"
  tmux select-pane -T "$name" >/dev/null 2>&1 || true
}

# --- Config parsing ---
trim_value() {
  local value="$1"
  value="${value#"${value%%[![:space:]]*}"}"
  value="${value%"${value##*[![:space:]]}"}"
  printf '%s' "$value"
}

normalize_value() {
  local value
  value="$(trim_value "$1")"
  if [[ "$value" == \"*\" && "$value" == *\" ]]; then
    value="${value:1:${#value}-2}"
  elif [[ "$value" == \'*\' && "$value" == *\' ]]; then
    value="${value:1:${#value}-2}"
  fi
  case "$value" in
    null|NULL|Null|"~")
      value=""
      ;;
  esac
  printf '%s' "$value"
}

load_config() {
  if [[ ! -f "$CONFIG_PATH" ]]; then
    cat <<'EOF' >&2
Missing config file: ~/.config/trudger.yml

Sample configurations:

1) Trudgeable with hooks
   - Selects the next ready br task labeled "trudgeable".
   - On completion, removes the "trudgeable" label.
   - On requires-human, removes "trudgeable" and adds "human-required".
   mkdir -p ~/.config && curl -fsSL https://raw.githubusercontent.com/lambdamechanic/trudger/main/sample_configuration/trudgeable-with-hooks.yml -o ~/.config/trudger.yml

2) Robot triage
   - Selects tasks via `bv --robot-next`.
   - No label changes (hooks are no-ops).
   mkdir -p ~/.config && curl -fsSL https://raw.githubusercontent.com/lambdamechanic/trudger/main/sample_configuration/robot-triage.yml -o ~/.config/trudger.yml
EOF
    exit 1
  fi

  local section=""
  local line key value
  while IFS= read -r line || [[ -n "$line" ]]; do
    line="${line%%#*}"
    line="${line%"${line##*[![:space:]]}"}"
    if [[ -z "${line//[[:space:]]/}" ]]; then
      continue
    fi

    if [[ "$line" =~ ^([A-Za-z0-9_]+):[[:space:]]*(.*)$ ]]; then
      key="${BASH_REMATCH[1]}"
      value="$(normalize_value "${BASH_REMATCH[2]}")"
      case "$key" in
        hooks|commands)
          if [[ -z "$value" ]]; then
            section="$key"
            continue
          fi
          ;;
        *)
          section=""
          ;;
      esac
      case "$key" in
        codex_command)
          codex_command="$value"
          ;;
        review_loop_limit)
          review_loop_limit="$value"
          ;;
        log_path)
          trudger_log_path="$value"
          ;;
        *)
          ;;
      esac
      continue
    fi

    if [[ "$line" =~ ^[[:space:]]+([A-Za-z0-9_]+):[[:space:]]*(.*)$ ]]; then
      key="${BASH_REMATCH[1]}"
      value="$(normalize_value "${BASH_REMATCH[2]}")"
      case "$section" in
        hooks)
          case "$key" in
            on_completed)
              hook_on_completed="$value"
              ;;
            on_requires_human)
              hook_on_requires_human="$value"
              ;;
            *)
              ;;
          esac
          ;;
        commands)
          case "$key" in
            next_task)
              next_task_command="$value"
              ;;
            task_show)
              task_show_command="$value"
              ;;
            task_update_in_progress)
              task_update_in_progress_command="$value"
              ;;
            *)
              ;;
          esac
          ;;
        *)
          ;;
      esac
      continue
    fi
  done < "$CONFIG_PATH"
}

validate_config() {
  if [[ -z "$codex_command" ]]; then
    printf 'codex_command must not be empty.\n' >&2
    exit 1
  fi
  if [[ -z "$next_task_command" ]]; then
    printf 'commands.next_task must not be empty.\n' >&2
    exit 1
  fi
  if [[ -z "$task_show_command" ]]; then
    printf 'commands.task_show must not be empty.\n' >&2
    exit 1
  fi
  if [[ -z "$task_update_in_progress_command" ]]; then
    printf 'commands.task_update_in_progress must not be empty.\n' >&2
    exit 1
  fi
  if [[ -z "$hook_on_completed" ]]; then
    printf 'hooks.on_completed must not be empty.\n' >&2
    exit 1
  fi
  if [[ -z "$hook_on_requires_human" ]]; then
    printf 'hooks.on_requires_human must not be empty.\n' >&2
    exit 1
  fi
  if [[ -z "$trudger_log_path" ]]; then
    printf 'log_path must not be empty.\n' >&2
    exit 1
  fi
  if ! [[ "$review_loop_limit" =~ ^[0-9]+$ ]] || ((review_loop_limit < 1)); then
    printf 'review_loop_limit must be a positive integer (got %s).\n' "$review_loop_limit" >&2
    exit 1
  fi
}

# --- Command helpers ---
parse_command() {
  local input="$1"
  # shellcheck disable=SC2034
  local -n out="$2"
  out=()
  if [[ -n "$input" ]]; then
    if ! mapfile -d '' -t out < <(bash -c 'set -f; eval "set -- $1"; printf "%s\0" "$@"' -- "$input"); then
      printf 'Failed to parse command: %s\n' "$input" >&2
      exit 1
    fi
  fi
}

run_hook() {
  local hook_command="$1"
  local task_id="$2"
  if [[ -z "$hook_command" ]]; then
    return 0
  fi
  if [[ "$hook_command" == *'$1'* || "$hook_command" == *'${1}'* ]]; then
    bash -lc "$hook_command" hook "$task_id"
    return 0
  fi
  local hook_parts=()
  parse_command "$hook_command" hook_parts
  if ((${#hook_parts[@]} == 0)); then
    return 0
  fi
  "${hook_parts[0]}" "$task_id" "${hook_parts[@]:1}"
}

run_task_command() {
  local command="$1"
  local task_id="$2"
  shift 2
  local extra_args=("$@")

  if [[ -z "$command" ]]; then
    return 0
  fi
  if [[ "$command" == *'$1'* || "$command" == *'${1}'* ]]; then
    bash -lc "$command" task "$task_id" "${extra_args[@]}"
    return $?
  fi
  local parts=()
  parse_command "$command" parts
  if ((${#parts[@]} == 0)); then
    return 0
  fi
  "${parts[@]}" "$task_id" "${extra_args[@]}"
}

run_task_show() {
  local task_id="$1"
  shift
  run_task_command "$task_show_command" "$task_id" "$@"
}

# --- Task selection and state ---
get_next_task_id() {
  local raw exit_code
  raw="$(bash -lc "${next_task_command}" 2>/dev/null)"
  exit_code=$?
  if [[ "$exit_code" -eq 1 ]]; then
    log_transition "idle next_task_exit=1"
    exit 0
  fi
  if [[ "$exit_code" -ne 0 ]]; then
    printf 'next_task command failed with exit code %s.\n' "$exit_code" >&2
    exit "$exit_code"
  fi
  printf '%s' "$raw" | awk 'NF { print $1; exit }'
}

load_task_state() {
  local task_id="$1"
  local raw
  raw="$(run_task_show "$task_id" --json)"
  printf '%s' "$raw" | jq -r '
    def item: if type == "array" then .[0] else . end;
    if (type == "array" and length == 0) or type == "null" then
      ["", ""]
    else
      item | [(.status // ""), ((.labels // []) | join(" "))]
    end
    | .[]
  ' 2>/dev/null || true
}

ensure_task_ready() {
  local task_id="$1"
  local task_state status
  mapfile -t task_state < <(load_task_state "$task_id")
  status="${task_state[0]:-}"

  case "$status" in
    ready|open)
      return 0
      ;;
    *)
      printf 'Task %s is not ready (status: %s).\n' "$task_id" "${status:-unknown}" >&2
      exit 1
      ;;
  esac
}

# --- Prompt rendering ---
render_prompt() {
  local prompt_path="$1"
  local task_context="$2"
  local content

  content="$(awk '
    NR == 1 && $0 == "---" { in_frontmatter = 1; next }
    in_frontmatter && $0 == "---" { in_frontmatter = 0; next }
    !in_frontmatter { print }
  ' "$prompt_path")"
  printf '%s' "${content//\$ARGUMENTS/$task_context}"
}

# --- Main ---
manual_tasks=()
while (($#)); do
  case "$1" in
    -h|--help)
      usage
      exit 0
      ;;
    --)
      shift
      manual_tasks+=("$@")
      break
      ;;
    -*)
      printf 'Unknown option: %s\n' "$1" >&2
      usage
      exit 1
      ;;
    *)
      manual_tasks+=("$1")
      ;;
  esac
  shift
done

codex_command=""
next_task_command=""
task_show_command=""
task_update_in_progress_command=""
review_loop_limit=""
trudger_log_path=""
hook_on_completed=""
hook_on_requires_human=""

load_config
validate_config

require_jq
require_prompt "$PROMPT_TRUDGE"
require_prompt "$PROMPT_REVIEW"
init_tmux_base_name

completed_tasks=()
needs_human_tasks=()
if [[ -n "${TRUDGER_COMPLETED:-}" ]]; then
  IFS=',' read -r -a completed_tasks <<< "${TRUDGER_COMPLETED}"
fi
if [[ -n "${TRUDGER_NEEDS_HUMAN:-}" ]]; then
  IFS=',' read -r -a needs_human_tasks <<< "${TRUDGER_NEEDS_HUMAN}"
fi
current_task_id=""
current_phase=""

codex_cmd=()
parse_command "$codex_command" codex_cmd
review_cmd=("${codex_cmd[@]}" resume --last)

handle_error() {
  if [[ -n "${current_task_id}" ]]; then
    update_tmux_name "ERROR" "$current_task_id"
    log_transition "error task=${current_task_id}"
  fi
}

trap handle_error ERR

handle_interrupt() {
  if [[ -n "${current_task_id}" ]]; then
    update_tmux_name "ERROR" "$current_task_id"
    log_transition "interrupt task=${current_task_id}"
  fi
  exit 130
}

trap handle_interrupt INT

restore_tmux_pane_title() {
  if ! is_tmux_session; then
    return 0
  fi
  if [[ -n "${tmux_original_pane_title:-}" ]]; then
    tmux select-pane -T "${tmux_original_pane_title}" >/dev/null 2>&1 || true
  fi
}

handle_exit() {
  local exit_code="$?"
  restore_tmux_pane_title
  log_transition "exit code=${exit_code}"
}

trap handle_exit EXIT

if ((${#manual_tasks[@]} > 0)); then
  for task_id in "${manual_tasks[@]}"; do
    ensure_task_ready "$task_id"
  done
fi

if ((${#manual_tasks[@]} > 0)); then
  task_id="${manual_tasks[0]}"
  manual_tasks=("${manual_tasks[@]:1}")
else
  task_id="$(get_next_task_id)"
fi
if [[ -z "$task_id" ]]; then
  log_transition "idle no_task"
  exit 0
fi

ensure_task_ready "$task_id"

review_loops=0
while true; do
  current_task_id="$task_id"
  current_phase="SOLVING"
  update_tmux_name "$current_phase" "$task_id"
  log_transition "state=SOLVING task=${task_id} loop=${review_loops}"

  run_task_command "$task_update_in_progress_command" "$task_id" --status in_progress
  task_show_output="$(run_task_show "$task_id" --json)"
  if ! "${codex_cmd[@]}" "$(render_prompt "$PROMPT_TRUDGE" "$task_show_output")"; then
    update_tmux_name "ERROR" "$task_id"
    log_transition "solve_failed task=${task_id}"
    printf 'Codex solve failed for task %s.\n' "$task_id" >&2
    exit 1
  fi
  current_phase="REVIEWING"
  update_tmux_name "$current_phase" "$task_id"
  log_transition "state=REVIEWING task=${task_id} loop=${review_loops}"
  task_show_output="$(run_task_show "$task_id" --json)"
  if ! "${review_cmd[@]}" "$(render_prompt "$PROMPT_REVIEW" "$task_show_output")"; then
    update_tmux_name "ERROR" "$task_id"
    log_transition "review_failed task=${task_id}"
    printf 'Codex review failed for task %s.\n' "$task_id" >&2
    exit 1
  fi

  mapfile -t task_state < <(load_task_state "$task_id")
  status="${task_state[0]:-}"
  labels="${task_state[1]:-}"
  log_transition "review_state task=${task_id} status=${status:-unknown} labels=${labels:-none}"

  if [[ -z "$status" ]]; then
    update_tmux_name "ERROR" "$task_id"
    log_transition "review_state_missing task=${task_id}"
    printf 'Task %s missing status after review.\n' "$task_id" >&2
    exit 1
  fi

  if [[ "$status" == "closed" ]]; then
    completed_tasks+=("$task_id")
    log_transition "completed task=${task_id}"
    run_hook "$hook_on_completed" "$task_id"
    break
  fi

  needs_human_tasks+=("$task_id")
  log_transition "needs_human task=${task_id}"
  run_hook "$hook_on_requires_human" "$task_id"
  break
done

TRUDGER_COMPLETED="$(IFS=','; printf '%s' "${completed_tasks[*]:-}")"
export TRUDGER_COMPLETED
TRUDGER_NEEDS_HUMAN="$(IFS=','; printf '%s' "${needs_human_tasks[*]:-}")"
export TRUDGER_NEEDS_HUMAN

log_transition "reexec next_tasks=${#manual_tasks[@]}"
exec "$0" "${manual_tasks[@]}"

#!/usr/bin/env bash
set -euo pipefail
set -o errtrace

# trudger: loop over trudgeable bd tasks and run Codex solve+review prompts.

PROMPT_TRUDGE="${HOME}/.codex/prompts/trudge.md"
PROMPT_REVIEW="${HOME}/.codex/prompts/trudge_review.md"
TRUDGER_LOG="${TRUDGER_LOG:-./.trudger.log}"
TRUDGER_NEXT_CMD="${TRUDGER_NEXT_CMD:-}"

usage() {
  cat <<'EOF'
Usage: ./trudger [task_id ...]

Loop over ready bd tasks labeled trudgeable and run Codex solve+review prompts.
If task IDs are provided, they run first (in order) before bd ready tasks.
Set TRUDGER_NEXT_CMD to override task selection with a command that prints an id.
EOF
}

require_prompt() {
  local path="$1"
  if [[ ! -f "$path" ]]; then
    printf 'Missing prompt file: %s\n' "$path" >&2
    exit 1
  fi
}

require_jq() {
  if ! command -v jq >/dev/null 2>&1; then
    printf 'Missing dependency: jq\n' >&2
    exit 1
  fi
}

log_transition() {
  local message="$1"
  local ts
  ts="$(date -u '+%Y-%m-%dT%H:%M:%SZ')"
  printf '%s %s\n' "$ts" "$message" >> "$TRUDGER_LOG" 2>/dev/null || true
}

is_tmux_session() {
  [[ -n "${TMUX:-}" ]] && command -v tmux >/dev/null 2>&1
}

default_tmux_base_name() {
  local host folder command
  host="$(hostname -s 2>/dev/null || hostname 2>/dev/null || printf 'host')"
  folder="$(basename "$PWD")"
  command="$(basename "$0")"
  printf '(%s) %s: %s' "$host" "$folder" "$command"
}

init_tmux_base_name() {
  if ! is_tmux_session; then
    return 0
  fi

  tmux_session_name="${TRUDGER_TMUX_SESSION_NAME:-}"
  if [[ -z "${tmux_session_name}" ]]; then
    tmux_session_name="$(tmux display-message -p '#S' 2>/dev/null || true)"
  fi
  export TRUDGER_TMUX_SESSION_NAME="${tmux_session_name}"

  tmux_original_pane_title="${TRUDGER_TMUX_ORIGINAL_PANE_TITLE:-}"
  if [[ -z "${tmux_original_pane_title}" ]]; then
    tmux_original_pane_title="$(tmux display-message -p '#{pane_title}' 2>/dev/null || true)"
  fi
  export TRUDGER_TMUX_ORIGINAL_PANE_TITLE="${tmux_original_pane_title}"

  if [[ -n "${tmux_original_pane_title}" ]]; then
    tmux_base_name="$(printf '%s\n' "$tmux_original_pane_title" | sed -E 's/ (COMPLETED|NEEDS_HUMAN) \\[[^]]*\\]//g; s/ (SOLVING|REVIEWING) .*$//; s/ HALTED ON ERROR .*$//')"
  fi
  if [[ -z "${tmux_base_name:-}" ]]; then
    tmux_base_name="$(default_tmux_base_name)"
  fi
  tmux select-pane -T "${tmux_base_name}" >/dev/null 2>&1 || true
}

format_task_list() {
  local label="$1"
  shift
  if (($# == 0)); then
    printf '%s' ""
    return
  fi
  local IFS=", "
  printf '%s [%s]' "$label" "$*"
}

build_tmux_name() {
  local phase="$1"
  local task_id="$2"
  local base="${tmux_base_name:-}"
  if [[ "$base" =~ ^(.+):\ ([^[:space:]]+)$ ]]; then
    local prefix="${BASH_REMATCH[1]}"
    local command="${BASH_REMATCH[2]}"
    case "$command" in
      fg|codex)
        base="$prefix"
        ;;
    esac
  fi
  if [[ -z "$base" ]]; then
    base="$(default_tmux_base_name)"
  fi

  local activity=""
  case "$phase" in
    SOLVING)
      activity="SOLVING $task_id"
      ;;
    REVIEWING)
      activity="REVIEWING $task_id"
      ;;
    ERROR)
      activity="HALTED ON ERROR $task_id"
      ;;
    *)
      ;;
  esac

  local parts=()
  parts+=("$base")
  local completed_segment needs_human_segment
  completed_segment="$(format_task_list "COMPLETED" "${completed_tasks[@]:-}")"
  needs_human_segment="$(format_task_list "NEEDS_HUMAN" "${needs_human_tasks[@]:-}")"
  if [[ -n "$completed_segment" ]]; then
    parts+=("$completed_segment")
  fi
  if [[ -n "$needs_human_segment" ]]; then
    parts+=("$needs_human_segment")
  fi
  if [[ -n "$activity" ]]; then
    parts+=("$activity")
  fi

  local IFS=" "
  printf '%s' "${parts[*]}"
}

update_tmux_name() {
  local phase="$1"
  local task_id="$2"
  if ! is_tmux_session; then
    return 0
  fi

  local name
  name="$(build_tmux_name "$phase" "$task_id")"
  tmux select-pane -T "$name" >/dev/null 2>&1 || true
}

get_next_task_id() {
  local raw
  if [[ -n "${TRUDGER_NEXT_CMD}" ]]; then
    raw="$(bash -lc "${TRUDGER_NEXT_CMD}" 2>/dev/null || true)"
    printf '%s' "$raw" | awk 'NF { print $1; exit }'
    return 0
  fi
  raw="$(bd ready --json --label trudgeable --sort priority --limit 1)"
  printf '%s' "$raw" | jq -r 'if type == "array" and length > 0 then .[0].id // "" else "" end' 2>/dev/null || true
}

load_task_state() {
  local task_id="$1"
  local raw
  raw="$(bd show "$task_id" --json)"
  printf '%s' "$raw" | jq -r '
    def item: if type == "array" then .[0] else . end;
    if (type == "array" and length == 0) or type == "null" then
      ["", ""]
    else
      item | [(.status // ""), ((.labels // []) | join(" "))]
    end
    | .[]
  ' 2>/dev/null || true
}

ensure_task_ready() {
  local task_id="$1"
  local task_state status labels
  mapfile -t task_state < <(load_task_state "$task_id")
  status="${task_state[0]:-}"
  labels="${task_state[1]:-}"

  if [[ "$status" != "ready" ]]; then
    printf 'Task %s is not ready (status: %s).\n' "$task_id" "${status:-unknown}" >&2
    exit 1
  fi
  if ! printf '%s' "$labels" | grep -q -- 'trudgeable'; then
    printf 'Task %s is not trudgeable.\n' "$task_id" >&2
    exit 1
  fi
}

ensure_task_ready_unlabeled() {
  local task_id="$1"
  local task_state status
  mapfile -t task_state < <(load_task_state "$task_id")
  status="${task_state[0]:-}"

  if [[ "$status" != "ready" ]]; then
    printf 'Task %s is not ready (status: %s).\n' "$task_id" "${status:-unknown}" >&2
    exit 1
  fi
}

render_prompt() {
  local prompt_path="$1"
  local task_id="$2"
  local content

  content="$(awk '
    NR == 1 && $0 == "---" { in_frontmatter = 1; next }
    in_frontmatter && $0 == "---" { in_frontmatter = 0; next }
    !in_frontmatter { print }
  ' "$prompt_path")"
  printf '%s' "${content//\$ARGUMENTS/$task_id}"
}

manual_tasks=()
while (($#)); do
  case "$1" in
    -h|--help)
      usage
      exit 0
      ;;
    --)
      shift
      manual_tasks+=("$@")
      break
      ;;
    -*)
      printf 'Unknown option: %s\n' "$1" >&2
      usage
      exit 1
      ;;
    *)
      manual_tasks+=("$1")
      ;;
  esac
  shift
done

require_jq
require_prompt "$PROMPT_TRUDGE"
require_prompt "$PROMPT_REVIEW"
init_tmux_base_name

completed_tasks=()
needs_human_tasks=()
if [[ -n "${TRUDGER_COMPLETED:-}" ]]; then
  IFS=',' read -r -a completed_tasks <<< "${TRUDGER_COMPLETED}"
fi
if [[ -n "${TRUDGER_NEEDS_HUMAN:-}" ]]; then
  IFS=',' read -r -a needs_human_tasks <<< "${TRUDGER_NEEDS_HUMAN}"
fi
current_task_id=""
current_phase=""
review_loop_limit="${TRUDGER_REVIEW_LOOPS:-5}"

if ! [[ "$review_loop_limit" =~ ^[0-9]+$ ]] || ((review_loop_limit < 1)); then
  printf 'TRUDGER_REVIEW_LOOPS must be a positive integer (got %s).\n' "$review_loop_limit" >&2
  exit 1
fi

handle_error() {
  if [[ -n "${current_task_id}" ]]; then
    update_tmux_name "ERROR" "$current_task_id"
    log_transition "error task=${current_task_id}"
  fi
}

trap handle_error ERR

handle_interrupt() {
  if [[ -n "${current_task_id}" ]]; then
    update_tmux_name "ERROR" "$current_task_id"
    log_transition "interrupt task=${current_task_id}"
  fi
  exit 130
}

trap handle_interrupt INT

restore_tmux_pane_title() {
  if ! is_tmux_session; then
    return 0
  fi
  if [[ -n "${tmux_original_pane_title:-}" ]]; then
    tmux select-pane -T "${tmux_original_pane_title}" >/dev/null 2>&1 || true
  fi
}

handle_exit() {
  local exit_code="$?"
  restore_tmux_pane_title
  log_transition "exit code=${exit_code}"
}

trap handle_exit EXIT

if ((${#manual_tasks[@]} > 0)); then
  for task_id in "${manual_tasks[@]}"; do
    ensure_task_ready "$task_id"
  done
fi

if [[ -n "${TRUDGER_NEXT_CMD}" ]]; then
  if ((${#manual_tasks[@]} > 0)); then
    printf 'Cannot combine manual task IDs with TRUDGER_NEXT_CMD.\n' >&2
    exit 1
  fi
fi

if ((${#manual_tasks[@]} > 0)); then
  task_id="${manual_tasks[0]}"
  manual_tasks=("${manual_tasks[@]:1}")
else
  task_id="$(get_next_task_id)"
fi
if [[ -z "$task_id" ]]; then
  log_transition "idle no_task"
  exit 0
fi

if [[ -n "${TRUDGER_NEXT_CMD}" ]]; then
  ensure_task_ready_unlabeled "$task_id"
  if ! bd label list "$task_id" 2>/dev/null | grep -q -- 'trudgeable'; then
    bd label add "$task_id" trudgeable
  fi
fi

review_loops=0
while true; do
  current_task_id="$task_id"
  current_phase="SOLVING"
  update_tmux_name "$current_phase" "$task_id"
  log_transition "state=SOLVING task=${task_id} loop=${review_loops}"

  bd update "$task_id" --status in_progress
  if ! codex --yolo exec "$(render_prompt "$PROMPT_TRUDGE" "$task_id")"; then
    update_tmux_name "ERROR" "$task_id"
    log_transition "solve_failed task=${task_id}"
    printf 'Codex solve failed for task %s.\n' "$task_id" >&2
    exit 1
  fi
  current_phase="REVIEWING"
  update_tmux_name "$current_phase" "$task_id"
  log_transition "state=REVIEWING task=${task_id} loop=${review_loops}"
  if ! codex --yolo exec resume --last "$(render_prompt "$PROMPT_REVIEW" "$task_id")"; then
    update_tmux_name "ERROR" "$task_id"
    log_transition "review_failed task=${task_id}"
    printf 'Codex review failed for task %s.\n' "$task_id" >&2
    exit 1
  fi

  mapfile -t task_state < <(load_task_state "$task_id")
  status="${task_state[0]:-}"
  labels="${task_state[1]:-}"
  log_transition "review_state task=${task_id} status=${status:-unknown} labels=${labels:-none}"

  if [[ "$status" == "closed" ]]; then
    completed_tasks+=("$task_id")
    log_transition "completed task=${task_id}"
    if printf '%s' "$labels" | grep -q -- 'trudgeable'; then
      bd label remove "$task_id" trudgeable
    fi
    break
  fi

  if printf '%s' "$labels" | grep -q -- 'requires-human'; then
    needs_human_tasks+=("$task_id")
    log_transition "needs_human task=${task_id}"
    if printf '%s' "$labels" | grep -q -- 'trudgeable'; then
      bd label remove "$task_id" trudgeable
    fi
    bd label add "$task_id" requires-human
    break
  fi

  review_loops=$((review_loops + 1))
  log_transition "loop_continue task=${task_id} loop=${review_loops}"
  if ((review_loops >= review_loop_limit)); then
    update_tmux_name "ERROR" "$task_id"
    log_transition "loop_limit task=${task_id} loop=${review_loops} limit=${review_loop_limit}"
    printf 'Task %s not closed and not requires-human after %s review loops.\n' "$task_id" "$review_loop_limit" >&2
    exit 1
  fi
done

export TRUDGER_COMPLETED="$(IFS=','; printf '%s' "${completed_tasks[*]:-}")"
export TRUDGER_NEEDS_HUMAN="$(IFS=','; printf '%s' "${needs_human_tasks[*]:-}")"

log_transition "reexec next_tasks=${#manual_tasks[@]}"
exec "$0" "${manual_tasks[@]}"

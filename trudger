#!/usr/bin/env bash
set -euo pipefail
set -o errtrace

# trudger: loop over br tasks and run agent solve+review prompts.

PROMPT_TRUDGE="${HOME}/.codex/prompts/trudge.md"
PROMPT_REVIEW="${HOME}/.codex/prompts/trudge_review.md"
DEFAULT_CONFIG_PATH="${HOME}/.config/trudger.yml"
CONFIG_PATH="${DEFAULT_CONFIG_PATH}"
CONFIG_PATH_SOURCE="default"

# --- Usage ---
usage() {
  cat <<'EOF'
Usage: ./trudger [options] [task_id ...]

Loop over ready br tasks and run agent solve+review prompts.
If task IDs are provided, they run first (in order) before br ready tasks.
Configuration is loaded from ~/.config/trudger.yml by default.

Options:
  -c, --config PATH   Load configuration from PATH instead of ~/.config/trudger.yml.
  -h, --help          Show this help text.
EOF
}

# --- Environment checks ---
require_prompt() {
  local path="$1"
  if [[ ! -f "$path" ]]; then
    printf 'Missing prompt file: %s\n' "$path" >&2
    quit "missing_prompt:${path}" 1
  fi
}

require_jq() {
  if ! command -v jq >/dev/null 2>&1; then
    printf 'Missing dependency: jq\n' >&2
    quit "missing_dependency:jq" 1
  fi
}

# --- Logging ---
log_transition() {
  local message="$1"
  local ts
  ts="$(date -u '+%Y-%m-%dT%H:%M:%SZ')"
  local path="${trudger_log_path:-}"
  if [[ -z "$path" ]]; then
    return 0
  fi
  message="$(sanitize_log_value "$message")"
  printf '%s %s\n' "$ts" "$message" >> "$path" 2>/dev/null || true
}

sanitize_log_value() {
  local value="$1"
  value="${value//$'\n'/\\n}"
  value="${value//$'\r'/\\r}"
  value="${value//$'\t'/\\t}"
  printf '%s' "$value"
}

quit() {
  local reason="${1:-}"
  local code="${2:-0}"
  local sanitized
  if [[ -z "$reason" ]]; then
    sanitized="unknown"
  else
    sanitized="$(sanitize_log_value "$reason")"
  fi
  log_transition "quit reason=${sanitized}"
  exit "$code"
}

# --- Tmux helpers ---
is_tmux_session() {
  [[ -n "${TMUX:-}" ]] && command -v tmux >/dev/null 2>&1
}

default_tmux_base_name() {
  local host folder command
  host="$(hostname -s 2>/dev/null || hostname 2>/dev/null || printf 'host')"
  folder="$(basename "$PWD")"
  command="$(basename "$0")"
  printf '(%s) %s: %s' "$host" "$folder" "$command"
}

init_tmux_base_name() {
  if ! is_tmux_session; then
    return 0
  fi

  tmux_session_name="${TRUDGER_TMUX_SESSION_NAME:-}"
  if [[ -z "${tmux_session_name}" ]]; then
    tmux_session_name="$(tmux display-message -p '#S' 2>/dev/null || true)"
  fi
  export TRUDGER_TMUX_SESSION_NAME="${tmux_session_name}"

  tmux_original_pane_title="${TRUDGER_TMUX_ORIGINAL_PANE_TITLE:-}"
  if [[ -z "${tmux_original_pane_title}" ]]; then
    tmux_original_pane_title="$(tmux display-message -p '#{pane_title}' 2>/dev/null || true)"
  fi
  export TRUDGER_TMUX_ORIGINAL_PANE_TITLE="${tmux_original_pane_title}"

  if [[ -n "${tmux_original_pane_title}" ]]; then
    tmux_base_name="$(printf '%s\n' "$tmux_original_pane_title" | sed -E 's/ (COMPLETED|NEEDS_HUMAN) \\[[^]]*\\]//g; s/ (SOLVING|REVIEWING) .*$//; s/ HALTED ON ERROR .*$//')"
  fi
  if [[ -z "${tmux_base_name:-}" ]]; then
    tmux_base_name="$(default_tmux_base_name)"
  fi
  tmux select-pane -T "${tmux_base_name}" >/dev/null 2>&1 || true
}

format_task_list() {
  local label="$1"
  shift
  if (($# == 0)); then
    printf '%s' ""
    return
  fi
  local IFS=", "
  printf '%s [%s]' "$label" "$*"
}

build_tmux_name() {
  local phase="$1"
  local task_id="$2"
  local base="${tmux_base_name:-}"
  if [[ "$base" =~ ^(.+):\ ([^[:space:]]+)$ ]]; then
    local prefix="${BASH_REMATCH[1]}"
    local command="${BASH_REMATCH[2]}"
    case "$command" in
      fg|codex)
        base="$prefix"
        ;;
    esac
  fi
  if [[ -z "$base" ]]; then
    base="$(default_tmux_base_name)"
  fi

  local activity=""
  case "$phase" in
    SOLVING)
      activity="SOLVING $task_id"
      ;;
    REVIEWING)
      activity="REVIEWING $task_id"
      ;;
    ERROR)
      activity="HALTED ON ERROR $task_id"
      ;;
    *)
      ;;
  esac

  local parts=()
  parts+=("$base")
  local completed_segment needs_human_segment
  completed_segment="$(format_task_list "COMPLETED" "${completed_tasks[@]:-}")"
  needs_human_segment="$(format_task_list "NEEDS_HUMAN" "${needs_human_tasks[@]:-}")"
  if [[ -n "$completed_segment" ]]; then
    parts+=("$completed_segment")
  fi
  if [[ -n "$needs_human_segment" ]]; then
    parts+=("$needs_human_segment")
  fi
  if [[ -n "$activity" ]]; then
    parts+=("$activity")
  fi

  local IFS=" "
  printf '%s' "${parts[*]}"
}

update_tmux_name() {
  local phase="$1"
  local task_id="$2"
  if ! is_tmux_session; then
    return 0
  fi

  local name
  name="$(build_tmux_name "$phase" "$task_id")"
  tmux select-pane -T "$name" >/dev/null 2>&1 || true
}

# --- Config parsing ---
require_yq() {
  if ! command -v yq >/dev/null 2>&1; then
    cat <<'EOF' >&2
Missing dependency: yq

Install yq and ensure it is on your PATH, then re-run trudger.
Common options:
  - macOS: brew install yq
  - Linux: https://github.com/mikefarah/yq#install
EOF
    quit "missing_dependency:yq" 1
  fi
}

detect_yq_mode() {
  local err=""
  if err="$(yq eval -r '.' "$CONFIG_PATH" 2>&1 >/dev/null)"; then
    if [[ -z "$err" ]]; then
      printf '%s' "mikefarah"
      return 0
    fi
  fi
  if err="$(yq -r '.' "$CONFIG_PATH" 2>&1 >/dev/null)"; then
    if [[ -z "$err" ]]; then
      printf '%s' "kislyuk"
      return 0
    fi
  fi
  return 1
}

read_config_value() {
  local query="$1"
  local mode="$2"
  local value
  if [[ "$mode" == "mikefarah" ]]; then
    value="$(yq eval -r "$query" "$CONFIG_PATH")"
  else
    value="$(yq -r "$query" "$CONFIG_PATH")"
  fi
  if [[ "$value" == "null" ]]; then
    value=""
  fi
  printf '%s' "$value"
}

config_has_key() {
  local key="$1"
  local mode="$2"
  local value
  if [[ "$mode" == "mikefarah" ]]; then
    value="$(yq eval -r "has(\"${key}\")" "$CONFIG_PATH")"
  else
    value="$(yq -r "has(\"${key}\")" "$CONFIG_PATH")"
  fi
  [[ "$value" == "true" ]]
}

load_config() {
  if [[ ! -f "$CONFIG_PATH" ]]; then
    if [[ "$CONFIG_PATH_SOURCE" == "flag" ]]; then
      printf 'Missing config file: %s\n' "$CONFIG_PATH" >&2
      quit "missing_config:${CONFIG_PATH}" 1
    fi
    cat <<'EOF' >&2
Missing config file: ~/.config/trudger.yml

Sample configurations:

1) Trudgeable with hooks
   - Selects the next ready br task labeled "trudgeable".
   - On completion, removes the "trudgeable" label.
   - On requires-human, removes "trudgeable" and adds "human-required".
   mkdir -p ~/.config && curl -fsSL https://raw.githubusercontent.com/lambdamechanic/trudger/main/sample_configuration/trudgeable-with-hooks.yml -o ~/.config/trudger.yml

2) Robot triage
   - Selects tasks via `bv --robot-next`.
   - No label changes (hooks are no-ops).
   mkdir -p ~/.config && curl -fsSL https://raw.githubusercontent.com/lambdamechanic/trudger/main/sample_configuration/robot-triage.yml -o ~/.config/trudger.yml
EOF
    quit "missing_config:${CONFIG_PATH}" 1
  fi

  require_yq

  local yq_mode
  if ! yq_mode="$(detect_yq_mode)"; then
    printf 'Invalid config file (failed to parse YAML): %s\n' "$CONFIG_PATH" >&2
    quit "invalid_config_parse:${CONFIG_PATH}" 1
  fi

  agent_command="$(read_config_value '.agent_command' "$yq_mode")"
  agent_review_command="$(read_config_value '.agent_review_command' "$yq_mode")"
  review_loop_limit="$(read_config_value '.review_loop_limit' "$yq_mode")"
  trudger_log_path="$(read_config_value '.log_path' "$yq_mode")"
  next_task_command="$(read_config_value '.commands.next_task' "$yq_mode")"
  task_show_command="$(read_config_value '.commands.task_show' "$yq_mode")"
  task_status_command="$(read_config_value '.commands.task_status' "$yq_mode")"
  task_update_in_progress_command="$(read_config_value '.commands.task_update_in_progress' "$yq_mode")"
  hook_on_completed="$(read_config_value '.hooks.on_completed' "$yq_mode")"
  hook_on_requires_human="$(read_config_value '.hooks.on_requires_human' "$yq_mode")"

  if config_has_key "codex_command" "$yq_mode"; then
    printf 'Migration: codex_command is no longer supported; use agent_command and agent_review_command.\n' >&2
    quit "invalid_codex_command" 1
  fi

  local key
  while IFS= read -r key; do
    case "$key" in
      agent_command|agent_review_command|commands|hooks|review_loop_limit|log_path)
        ;;
      codex_command)
        printf 'Migration: codex_command is no longer supported; use agent_command and agent_review_command.\n' >&2
        quit "invalid_codex_command" 1
        ;;
      *)
        printf 'Warning: Unknown config key: %s\n' "$key" >&2
        ;;
    esac
  done < <(if [[ "$yq_mode" == "mikefarah" ]]; then yq eval -r 'keys | .[]' "$CONFIG_PATH"; else yq -r 'keys | .[]' "$CONFIG_PATH"; fi)
}

validate_config() {
  if [[ -z "$agent_command" ]]; then
    printf 'agent_command must not be empty.\n' >&2
    quit "missing_agent_command" 1
  fi
  if [[ -z "$agent_review_command" ]]; then
    printf 'agent_review_command must not be empty.\n' >&2
    quit "missing_agent_review_command" 1
  fi
  if [[ -z "$next_task_command" ]]; then
    if ((${#manual_tasks[@]} > 0)); then
      printf 'Warning: commands.next_task is empty; manual task IDs provided, continuing without next_task.\n' >&2
    else
      printf 'commands.next_task must not be empty.\n' >&2
      printf 'Migration: add commands.next_task to your config (required when no manual task IDs). See README.md or sample_configuration/*.yml.\n' >&2
      quit "missing_next_task_command" 1
    fi
  fi
  if [[ -z "$task_show_command" ]]; then
    printf 'commands.task_show must not be empty.\n' >&2
    quit "missing_task_show_command" 1
  fi
  if [[ -z "$task_status_command" ]]; then
    printf 'commands.task_status must not be empty.\n' >&2
    quit "missing_task_status_command" 1
  fi
  if [[ -z "$task_update_in_progress_command" ]]; then
    printf 'commands.task_update_in_progress must not be empty.\n' >&2
    quit "missing_task_update_in_progress_command" 1
  fi
  if [[ -z "$hook_on_completed" ]]; then
    printf 'hooks.on_completed must not be empty.\n' >&2
    quit "missing_hook_on_completed" 1
  fi
  if [[ -z "$hook_on_requires_human" ]]; then
    printf 'hooks.on_requires_human must not be empty.\n' >&2
    quit "missing_hook_on_requires_human" 1
  fi
  if [[ -z "$trudger_log_path" ]]; then
    printf 'log_path must not be empty.\n' >&2
    quit "missing_log_path" 1
  fi
  if ! [[ "$review_loop_limit" =~ ^[0-9]+$ ]] || ((review_loop_limit < 1)); then
    printf 'review_loop_limit must be a positive integer (got %s).\n' "$review_loop_limit" >&2
    quit "invalid_review_loop_limit" 1
  fi
}

# --- Command helpers ---
run_shell_command() {
  local command="$1"
  local log_label="$2"
  local task_token="$3"
  shift 3
  local args=("$@")

  if [[ -z "$command" ]]; then
    return 0
  fi

  local args_render
  args_render="$(printf '%q ' "${args[@]}")"
  log_transition "cmd start label=${log_label} task=${task_token} mode=bash_lc command=$(sanitize_log_value "$command") args=$(sanitize_log_value "$args_render")"
  local errexit_enabled=0
  if [[ $- == *e* ]]; then
    errexit_enabled=1
  fi
  set +e
  local prev_err_trap=""
  prev_err_trap="$(trap -p ERR)"
  trap - ERR
  if ((${#args[@]} > 0)); then
    bash -lc "$command" -- "${args[@]}"
  else
    bash -lc "$command"
  fi
  local exit_code=$?
  if [[ -n "$prev_err_trap" ]]; then
    eval "$prev_err_trap"
  fi
  if ((errexit_enabled)); then
    set -e
  fi
  log_transition "cmd exit label=${log_label} task=${task_token} exit=${exit_code}"
  return "$exit_code"
}

set_prompt_env() {
  local prompt="${1:-}"
  local review_prompt="${2:-}"
  if [[ -n "$prompt" ]]; then
    export TRUDGER_PROMPT="$prompt"
  else
    unset TRUDGER_PROMPT
  fi
  if [[ -n "$review_prompt" ]]; then
    export TRUDGER_REVIEW_PROMPT="$review_prompt"
  else
    unset TRUDGER_REVIEW_PROMPT
  fi
}

set_task_show_state() {
  local value="$1"
  current_task_show="$value"
  current_task_show_set=1
  export TRUDGER_TASK_SHOW="$current_task_show"
}

set_task_status_state() {
  local value="$1"
  current_task_status="$value"
  current_task_status_set=1
  export TRUDGER_TASK_STATUS="$current_task_status"
}

clear_task_context_state() {
  current_task_show=""
  current_task_show_set=0
  current_task_status=""
  current_task_status_set=0
  unset TRUDGER_TASK_SHOW
  unset TRUDGER_TASK_STATUS
}

set_command_env() {
  local task_id="$1"
  local prompt="${2:-}"
  local review_prompt="${3:-}"

  export TRUDGER_CONFIG_PATH="$CONFIG_PATH"
  if [[ -n "$task_id" ]]; then
    export TRUDGER_TASK_ID="$task_id"
    if ((current_task_show_set)); then
      export TRUDGER_TASK_SHOW="$current_task_show"
    else
      unset TRUDGER_TASK_SHOW
    fi
    if ((current_task_status_set)); then
      export TRUDGER_TASK_STATUS="$current_task_status"
    else
      unset TRUDGER_TASK_STATUS
    fi
  else
    unset TRUDGER_TASK_ID
    unset TRUDGER_TASK_SHOW
    unset TRUDGER_TASK_STATUS
  fi
  set_prompt_env "$prompt" "$review_prompt"
}

run_config_command() {
  local command="$1"
  local task_id="$2"
  local shell_label="$3"
  local log_label="${4:-$shell_label}"
  shift 4
  local extra_args=("$@")

  if [[ -z "$command" ]]; then
    return 0
  fi

  local task_token="none"
  if [[ -n "$task_id" ]]; then
    task_token="$task_id"
  fi

  local args=()
  if ((${#extra_args[@]} > 0)); then
    args+=("${extra_args[@]}")
  fi
  set_command_env "$task_id" "" ""
  run_shell_command "$command" "$log_label" "$task_token" "${args[@]}"
}

run_agent_command() {
  local command="$1"
  local log_label="${2:-agent}"
  local prompt="${3:-}"
  local review_prompt="${4:-}"
  shift 4
  local args=("$@")

  set_command_env "${current_task_id:-}" "$prompt" "$review_prompt"
  run_shell_command "$command" "$log_label" "none" "${args[@]}"
}

run_hook() {
  local hook_command="$1"
  local task_id="$2"
  local hook_name="${3:-hook}"
  if [[ -z "$hook_command" ]]; then
    return 0
  fi
  run_config_command "$hook_command" "$task_id" "hook" "$hook_name"
}

run_task_command() {
  local command="$1"
  local task_id="$2"
  shift 2
  local extra_args=("$@")

  run_config_command "$command" "$task_id" "task" "task" "${extra_args[@]}"
}

run_task_show() {
  local task_id="$1"
  shift
  local raw exit_code
  local errexit_enabled=0
  if [[ $- == *e* ]]; then
    errexit_enabled=1
  fi
  local prev_err_trap=""
  prev_err_trap="$(trap -p ERR)"
  trap - ERR
  set +e
  current_task_show_set=0
  raw="$(run_task_command "$task_show_command" "$task_id" "$@")"
  exit_code=$?
  if [[ -n "$prev_err_trap" ]]; then
    eval "$prev_err_trap"
  fi
  if ((errexit_enabled)); then
    set -e
  fi
  if [[ "$exit_code" -ne 0 ]]; then
    printf 'task_show command failed with exit code %s.\n' "$exit_code" >&2
    quit "task_show_failed:${exit_code}" "$exit_code"
  fi
  set_task_show_state "$raw"
}

run_task_status() {
  local task_id="$1"
  run_task_command "$task_status_command" "$task_id"
}

reexec_trudger() {
  local reexec_path=""
  reexec_path="$(command -v "$0" 2>/dev/null || true)"
  if [[ -z "$reexec_path" ]]; then
    reexec_path="$0"
  fi
  local args=()
  if [[ "$CONFIG_PATH_SOURCE" == "flag" ]]; then
    args+=(--config "$CONFIG_PATH")
  fi
  if ((${#manual_tasks[@]} > 0)); then
    args+=("${manual_tasks[@]}")
  fi
  log_transition "reexec path=${reexec_path} next_tasks=${#manual_tasks[@]}"
  exec "$reexec_path" "${args[@]}"
}

# --- Task selection and state ---
get_next_task_id() {
  local raw exit_code
  local prev_err_trap=""
  prev_err_trap="$(trap -p ERR)"
  trap - ERR
  set +e
  raw="$(run_config_command "$next_task_command" "" "next-task" "next-task" 2>/dev/null)"
  exit_code=$?
  set -e
  if [[ -n "$prev_err_trap" ]]; then
    eval "$prev_err_trap"
  fi
  if [[ "$exit_code" -eq 1 ]]; then
    log_transition "idle next_task_exit=1"
    quit "no_next_task" 0
  fi
  if [[ "$exit_code" -ne 0 ]]; then
    printf 'next_task command failed with exit code %s.\n' "$exit_code" >&2
    quit "next_task_failed:${exit_code}" "$exit_code"
  fi
  printf '%s' "$raw" | awk 'NF { print $1; exit }'
}

task_status() {
  local task_id="$1"
  local raw exit_code status
  local errexit_enabled=0
  if [[ $- == *e* ]]; then
    errexit_enabled=1
  fi
  local prev_err_trap=""
  prev_err_trap="$(trap -p ERR)"
  trap - ERR
  set +e
  current_task_status_set=0
  raw="$(run_task_status "$task_id")"
  exit_code=$?
  if [[ -n "$prev_err_trap" ]]; then
    eval "$prev_err_trap"
  fi
  if ((errexit_enabled)); then
    set -e
  fi
  if [[ "$exit_code" -ne 0 ]]; then
    printf 'task_status command failed with exit code %s.\n' "$exit_code" >&2
    quit "task_status_failed:${exit_code}" "$exit_code"
  fi
  status="$(printf '%s' "$raw" | awk 'NF { print $1; exit }')"
  set_task_status_state "$status"
}

is_ready_status() {
  local status="$1"
  [[ "$status" == "ready" || "$status" == "open" ]]
}

ensure_task_ready() {
  local task_id="$1"
  local status
  task_status "$task_id"
  status="$current_task_status"
  if is_ready_status "$status"; then
    return 0
  fi
  printf 'Task %s is not ready (status: %s).\n' "$task_id" "${status:-unknown}" >&2
  quit "task_not_ready:${task_id}" 1
}

# --- Prompt rendering ---
render_prompt() {
  local prompt_path="$1"
  local content

  content="$(awk '
    NR == 1 && $0 == "---" { in_frontmatter = 1; next }
    in_frontmatter && $0 == "---" { in_frontmatter = 0; next }
    !in_frontmatter { print }
  ' "$prompt_path")"
  printf '%s' "${content}"
}

# --- Main ---
manual_tasks=()
while (($#)); do
  case "$1" in
    -h|--help)
      usage
      quit "help" 0
      ;;
    -c|--config)
      option="$1"
      shift
      if (($# == 0)) || [[ -z "$1" ]]; then
        printf 'Missing value for %s\n' "$option" >&2
        usage
        quit "missing_option_value:${option}" 1
      fi
      CONFIG_PATH="$1"
      CONFIG_PATH_SOURCE="flag"
      ;;
    --config=*)
      CONFIG_PATH="${1#*=}"
      CONFIG_PATH_SOURCE="flag"
      if [[ -z "$CONFIG_PATH" ]]; then
        printf 'Missing value for --config\n' >&2
        usage
        quit "missing_option_value:--config" 1
      fi
      ;;
    --)
      shift
      manual_tasks+=("$@")
      break
      ;;
    -*)
      printf 'Unknown option: %s\n' "$1" >&2
      usage
      quit "unknown_option:${1}" 1
      ;;
    *)
      manual_tasks+=("$1")
      ;;
  esac
  shift
done

agent_command=""
agent_review_command=""
next_task_command=""
task_show_command=""
task_status_command=""
task_update_in_progress_command=""
review_loop_limit=""
trudger_log_path=""
hook_on_completed=""
hook_on_requires_human=""

load_config
validate_config
export TRUDGER_CONFIG_PATH="$CONFIG_PATH"

require_jq
require_prompt "$PROMPT_TRUDGE"
require_prompt "$PROMPT_REVIEW"
prompt_trudge_content="$(render_prompt "$PROMPT_TRUDGE")"
prompt_review_content="$(render_prompt "$PROMPT_REVIEW")"
init_tmux_base_name

completed_tasks=()
needs_human_tasks=()
if [[ -n "${TRUDGER_COMPLETED:-}" ]]; then
  IFS=',' read -r -a completed_tasks <<< "${TRUDGER_COMPLETED}"
fi
if [[ -n "${TRUDGER_NEEDS_HUMAN:-}" ]]; then
  IFS=',' read -r -a needs_human_tasks <<< "${TRUDGER_NEEDS_HUMAN}"
fi
current_task_id=""
current_phase=""
current_task_show=""
current_task_show_set=0
current_task_status=""
current_task_status_set=0

review_args=("resume" "--last")

handle_error() {
  local exit_code="$?"
  if [[ -n "${current_task_id}" ]]; then
    update_tmux_name "ERROR" "$current_task_id"
    log_transition "error task=${current_task_id}"
  fi
  quit "error" "$exit_code"
}

trap handle_error ERR

if [[ -n "${TRUDGER_TEST_FORCE_ERR:-}" ]]; then
  false
fi

handle_interrupt() {
  if [[ -n "${current_task_id}" ]]; then
    update_tmux_name "ERROR" "$current_task_id"
    log_transition "interrupt task=${current_task_id}"
  fi
  quit "interrupt" 130
}

trap handle_interrupt INT

restore_tmux_pane_title() {
  if ! is_tmux_session; then
    return 0
  fi
  if [[ -n "${tmux_original_pane_title:-}" ]]; then
    tmux select-pane -T "${tmux_original_pane_title}" >/dev/null 2>&1 || true
  fi
}

handle_exit() {
  local exit_code="$?"
  restore_tmux_pane_title
  log_transition "exit code=${exit_code}"
}

trap handle_exit EXIT

if ((${#manual_tasks[@]} > 0)); then
  for task_id in "${manual_tasks[@]}"; do
    ensure_task_ready "$task_id"
  done
fi

while true; do
  task_id=""
  if ((${#manual_tasks[@]} > 0)); then
    task_id="${manual_tasks[0]}"
    manual_tasks=("${manual_tasks[@]:1}")
  else
    if [[ -z "$next_task_command" ]]; then
      log_transition "idle missing_next_task_command"
      quit "missing_next_task_command" 0
    fi
    skip_not_ready_limit="${TRUDGER_SKIP_NOT_READY_LIMIT:-5}"
    if ! [[ "$skip_not_ready_limit" =~ ^[0-9]+$ ]] || ((skip_not_ready_limit < 1)); then
      skip_not_ready_limit=5
    fi
    skip_count=0
    while true; do
      task_id="$(get_next_task_id)"
      if [[ -z "$task_id" ]]; then
        log_transition "idle no_task"
        quit "no_task" 0
      fi
      task_status "$task_id"
      status="$current_task_status"
      if [[ -z "$status" ]]; then
        printf 'Task %s missing status.\n' "$task_id" >&2
        quit "task_missing_status:${task_id}" 1
      fi
      if is_ready_status "$status"; then
        break
      fi
      log_transition "skip_not_ready task=${task_id} status=${status}"
      skip_count=$((skip_count + 1))
      if ((skip_count >= skip_not_ready_limit)); then
        log_transition "idle no_ready_task attempts=${skip_count}"
        printf 'Task %s is not ready (status: %s).\n' "$task_id" "$status" >&2
        quit "no_ready_task" 0
      fi
    done
  fi
  if [[ -z "$task_id" ]]; then
    log_transition "idle no_task"
    quit "no_task" 0
  fi

  clear_task_context_state
  review_loops=0
  while true; do
    current_task_id="$task_id"
    current_phase="SOLVING"
    update_tmux_name "$current_phase" "$task_id"
    log_transition "state=SOLVING task=${task_id} loop=${review_loops}"

  run_task_command "$task_update_in_progress_command" "$task_id" --status in_progress
  run_task_show "$task_id" --json
  if ! run_agent_command "$agent_command" "agent_solve" "$prompt_trudge_content" ""; then
    update_tmux_name "ERROR" "$task_id"
    log_transition "solve_failed task=${task_id}"
    printf 'Agent solve failed for task %s.\n' "$task_id" >&2
    quit "solve_failed:${task_id}" 1
  fi
  current_phase="REVIEWING"
  update_tmux_name "$current_phase" "$task_id"
  log_transition "state=REVIEWING task=${task_id} loop=${review_loops}"
  run_task_show "$task_id" --json
  if ! run_agent_command "$agent_review_command" "agent_review" "" "$prompt_review_content" "${review_args[@]}"; then
    update_tmux_name "ERROR" "$task_id"
    log_transition "review_failed task=${task_id}"
    printf 'Agent review failed for task %s.\n' "$task_id" >&2
    quit "review_failed:${task_id}" 1
  fi

  task_status "$task_id"
  status="$current_task_status"
  log_transition "review_state task=${task_id} status=${status:-unknown}"

  if [[ -z "$status" ]]; then
    update_tmux_name "ERROR" "$task_id"
    log_transition "review_state_missing task=${task_id}"
    printf 'Task %s missing status after review.\n' "$task_id" >&2
    quit "task_missing_status_after_review:${task_id}" 1
  fi

    if [[ "$status" == "closed" ]]; then
      completed_tasks+=("$task_id")
      log_transition "completed task=${task_id}"
      run_hook "$hook_on_completed" "$task_id" "on_completed"
      break
    fi

    needs_human_tasks+=("$task_id")
    log_transition "needs_human task=${task_id}"
    run_hook "$hook_on_requires_human" "$task_id" "on_requires_human"
    break
  done

  TRUDGER_COMPLETED="$(IFS=','; printf '%s' "${completed_tasks[*]:-}")"
  log_transition "env TRUDGER_COMPLETED=${TRUDGER_COMPLETED}"
  export TRUDGER_COMPLETED
  TRUDGER_NEEDS_HUMAN="$(IFS=','; printf '%s' "${needs_human_tasks[*]:-}")"
  export TRUDGER_NEEDS_HUMAN

  if [[ -n "$next_task_command" || ${#manual_tasks[@]} -gt 0 ]]; then
    reexec_trudger
  fi

  current_task_id=""
  current_phase=""
done

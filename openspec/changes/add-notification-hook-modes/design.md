## Context
Trudger currently supports outcome-specific hooks (`on_completed`, `on_requires_human`) and transition logging to `log_path`, but it has no dedicated notification path. Users need a configurable notification stream that can be low volume (run/task boundaries) or high volume (every transition log message).

## Goals / Non-Goals
- Goals:
  - Provide an optional notification hook for external systems (Discord, etc.).
  - Support three notification scopes: every transition log, task start/end, run start/end.
  - Provide consistent notification payload fields (duration, folder, task id, task description).
  - Keep notification failures non-fatal to task processing.
- Non-Goals:
  - Built-in Discord client integration.
  - Rich templating/rendering engine inside Trudger.
  - Retrofitting notification support into wizard-only flows beyond preserving/round-tripping new config keys.

## Decisions
- Decision: Add optional config keys under `hooks`.
  - `hooks.on_notification` (optional command)
  - `hooks.on_notification_scope` (optional enum: `all_logs`, `task_boundaries`, `run_boundaries`; default `task_boundaries` when hook is set)
  - Rationale: keeps all hook command concerns in a single config section and minimizes schema expansion.

- Decision: `hooks.on_notification_scope` without `hooks.on_notification` is ignored with a startup warning.
  - Rationale: avoids breaking existing configs that may pre-seed scope before hook rollout.

- Decision: Use dedicated notification env vars (`TRUDGER_NOTIFY_*`) for payload fields.
  - Rationale: avoids overloading existing command/hook env vars with event-specific semantics.

- Decision: Derive human-readable task description from `commands.task_show` output.
  - Rule: first non-empty line, trimmed; empty when unavailable.
  - Rationale: stable, tool-agnostic, and cheap to compute.

- Decision: Notification failures are fail-open.
  - Rationale: notifications are optional side effects and should not block task processing.

- Decision: Canonical notification events are fixed strings: `run_start`, `run_end`, `task_start`, `task_end`, and `log`.
  - Rationale: stable webhook contracts simplify downstream routing/formatting.

- Decision: Notification dispatch is task-processing-only (default `trudger` mode), not `wizard` or `doctor`.
  - Rationale: request scope is operational task-run notifications; wizard/doctor have different UX and failure semantics.

- Decision: Recursion guard is mandatory for `all_logs`.
  - Rule: transitions generated by notification delivery itself (for example notification failure transitions) do not generate further notification events.
  - Rationale: prevents infinite loops and unbounded notification storms.

- Decision: Duration semantics are deterministic by event type.
  - `run_start`: `0`
  - `run_end`: elapsed ms since run start
  - `task_start`: `0`
  - `task_end`: elapsed ms since task start
  - `log`: elapsed ms since run start
  - Rationale: predictable contract and easy downstream interpretation.

- Decision: `TRUDGER_NOTIFY_FOLDER` uses the absolute invocation working directory captured at startup.
  - Rationale: stable location identity regardless of per-command cwd overrides.

- Decision: `TRUDGER_NOTIFY_MESSAGE` in `all_logs` mode is redacted.
  - Rule: values of `command=` and `args=` segments in transition messages are replaced with `[REDACTED]` before notification payload emission.
  - Rationale: command strings may include sensitive arguments; downstream notifications should not leak them.
  - Compatibility: redaction output format is not a stable compatibility contract and may evolve.

- Decision: include run-end exit code in payload.
  - Rule: `TRUDGER_NOTIFY_EXIT_CODE` is set for `run_end` events and unset for other event types.
  - Rationale: downstream alerting often needs success/failure routing without parsing message text.

- Decision: `run_end` is emitted at the absolute end of task-processing teardown.
  - Rule: emit `run_end` after task-processing cleanup/reset/restore steps are complete.
  - Rationale: end notifications should represent fully finalized run state.

- Decision: attempt best-effort `run_end` emission for all termination paths that can execute user code.
  - Rule: include normal exits, handled interrupts, handled termination signals, and error exits; paths that cannot run code (for example hard kill) remain out of scope.
  - Rationale: maximize notification reliability without claiming impossible guarantees.

## Architecture Sketch
- Add notification config parsing/validation in `config.rs`.
- Add a notification dispatcher callable from:
  - run-level boundaries (`run_start`, `run_end`)
  - task-level boundaries (`task_start`, `task_end`)
  - transition logging path (`all_logs` mode)
- Dispatch executes `hooks.on_notification` via existing shell execution path (`bash -lc`) with no positional args and `TRUDGER_NOTIFY_*` env vars.
- Keep notification emission independent from `log_path` so notifications can work even when file logging is disabled.

## Risks / Trade-offs
- `all_logs` can be noisy and expensive when hooks call remote services.
  - Mitigation: explicit scope configuration; default to `task_boundaries`.
- Description extraction may be imperfect across trackers.
  - Mitigation: deterministic first-line rule and graceful empty fallback.
- Additional hook execution paths can introduce latency.
  - Mitigation: fail-open behavior and clear operational docs.

## Migration Plan
1. Existing configs continue to work unchanged (notification hook is optional).
2. Users opt in by adding `hooks.on_notification` and optional `hooks.on_notification_scope`.
3. Wizard/config generation paths are updated to preserve new keys during rewrites.

## Open Questions
- None blocking for proposal scope.
